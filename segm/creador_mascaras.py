# -*- coding: utf-8 -*-
"""creador_mascaras.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19zVSYAqP0D6gvExwiyeBasoMAvxDOUEa

## Descarga de datos e importación de librerías
"""

##from google.colab import drive //que porque no se puede conectar de google aqui, mejor trabajar con el entorno en la PC
#drive.mount('/content/drive')

#Instalar e importar librerías
import subprocess
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from scipy import signal
from skimage import exposure
import SimpleITK as sitk
import cv2
import warnings
import SimpleITK as sitk
from skimage.restoration import denoise_tv_chambolle
from skimage.filters import threshold_otsu
from skimage.morphology import binary_erosion, disk
from skimage.segmentation import clear_border
from skimage.measure import label, regionprops
from skimage.measure import find_contours
from skimage.draw import polygon
from skimage.transform import resize
from skimage.color import rgba2rgb, rgb2gray
import os
import sys  # Importar el módulo sys

warnings.filterwarnings("ignore")

#-------------------modificado 18/06-------------------------------------------------------------------------------
# Instalar librerías necesarias si no están instaladas
try:
    import SimpleITK
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", 'SimpleITK'])

try:
    import PIL
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", 'Pillow'])
#-------------------fin modificado 18/06-------------------------------------------------------------------------------

# Definir la ruta del las imágenes
path='C:\\Users\\Beatriz\\Desktop\\UPIBI\\ITBA IMAGENEOLOGÍA\\interfaz\\proyecto_PIB\\xrays segmentados\\todo\\pulmones'
path_mask='C:\\Users\\Beatriz\\Desktop\\UPIBI\\ITBA IMAGENEOLOGÍA\\interfaz\\proyecto_PIB\\xrays segmentados\\dataset\\train_mask'

# Definir la ruta del archivo de datos
path_archivo_datos = 'C:\\Users\\Beatriz\\Desktop\\UPIBI\\ITBA IMAGENEOLOGÍA\\interfaz\\proyecto_PIB\\clinical_information\\CLNDAT_EN.txt'

"""## Funciones"""

def reconstruir_nombre_archivo(numero, path):
    """
    Reconstruye el nombre del archivo de imagen a partir del número proporcionado.

    Args:
        numero (str): El número de la imagen, desde 1 hasta 154.
        path (str): La ruta base donde se encuentran los archivos .IMG.

    Returns:
        str: El nombre del archivo de imagen reconstruido.
    """
    # Construir el nombre del archivo .IMG
    try:
        numero=int(numero)
        nombre_archivo = f"{path}/imagen_{numero:03d} (1).png"
        nombre_auxiliar = f"{path}/JPCLN{numero:03d}.IMG"
        return nombre_archivo, nombre_auxiliar
    except Exception as e:
        print(f"Error al reconstruir el nombre del archivo para la imagen {numero}: {str(e)}")
        return None, None

def cargar_mostrar_imagen(nombre_archivo):
    """
    Carga una imagen PNG y la muestra utilizando matplotlib.

    Args:
        nombre_archivo (str): El nombre del archivo .PNG.
        cmap (str, optional): El mapa de colores a utilizar para mostrar la imagen. Por defecto, 'gray'.
    """
    # Cargar la imagen como un arreglo NumPy
    try:
        imagen = plt.imread(nombre_archivo)
        # Mostrar la imagen
        plt.imshow(imagen, cmap='gray')
        plt.axis('off')
        plt.show()
        return imagen
    except Exception as e:
        print(f"Error al cargar la imagen {nombre_archivo}: {str(e)}")
        return None

def redimensionar_arreglo(imagen, nueva_shape=(2048, 2048)):
    """
    Redimensiona un arreglo NumPy a una nueva forma y muestra la imagen resultante.

    Args:
        imagen (numpy.ndarray): La imagen como un arreglo NumPy.
        nueva_shape (tuple): La nueva forma deseada para la imagen.

    Returns:
        numpy.ndarray: La imagen redimensionada.
    """
    # Convertir la imagen a escala de grises si tiene 4 canales
    if imagen.shape[-1] == 4:
        imagen = rgba2rgb(imagen)
        imagen = rgb2gray(imagen)

    # Redimensionar el arreglo manteniendo los valores de píxel originales
    imagen_redimensionada = resize(imagen, nueva_shape, mode='reflect', anti_aliasing=True, preserve_range=True)

    # Mostrar la imagen redimensionada
    plt.imshow(imagen_redimensionada, cmap='gray', interpolation='bicubic')
    plt.axis('off')
    plt.show()

    return imagen_redimensionada

def convertir_a_8bits(imagen):
    """
    Convierte una imagen NumPy a 8 bits.

    Args:
        imagen (numpy.ndarray): La imagen NumPy.

    Returns:
        numpy.ndarray: La imagen convertida a 8 bits.
    """
    # Escalar la imagen al rango de 0 a 255
    imagen_escalada = (imagen - imagen.min()) * (255 / (imagen.max() - imagen.min()))

    # Convertir la imagen a 8 bits
    imagen_8bits = imagen_escalada.astype(np.uint8)

    return imagen_8bits

def encontrar_coordenadas_tumor(ruta_imagen, path):
    """
    Encuentra las coordenadas del tumor a partir de la ruta de la imagen en el archivo de datos y las devuelve como una tupla.

    Args:
        ruta_imagen (str): La ruta completa del archivo de imagen.
        path (str): La ruta del archivo que contiene los datos.

    Returns:
        tuple: Las coordenadas del tumor como una tupla (x, y), o None si la ruta de la imagen no se encuentra en el archivo de datos.
    """
    # Obtener el nombre del archivo de la ruta de la imagen
    nombre_archivo = os.path.basename(ruta_imagen)

    # Leer el archivo de datos
    with open(path, 'r') as archivo:
        # Leer todas las líneas del archivo
        lineas = archivo.readlines()
        # Buscar la línea que contiene el nombre del archivo
        for linea in lineas:
            if nombre_archivo in linea:
                # Dividir la línea en columnas
                columnas = linea.split()
                # Obtener las coordenadas x e y del tumor
                x = int(columnas[5])  # La columna 6 contiene la coordenada x
                y = int(columnas[6])  # La columna 7 contiene la coordenada y
                # Imprimir las coordenadas del tumor
                print("Las coordenadas del tumor son:", x, y)
                # Devolver las coordenadas del tumor como una tupla
                return x, y
    # Si no se encuentra la ruta de la imagen en el archivo de datos, imprimir un mensaje y devolver None
    print("El nombre del archivo no se encontró en el archivo de datos.")
    return None

def mostrar_imagen_con_punto(imagen, coordenadas_tumor):
    """
    Muestra una imagen y agrega un punto encima.

    Args:
        imagen (numpy.ndarray): La imagen como un arreglo NumPy.
        coordenadas_tumor (tuple): Las coordenadas del tumor en la imagen.

    Returns:
        numpy.ndarray: La imagen original como arreglo NumPy.
    """

    # Mostrar la imagen
    plt.imshow(imagen, cmap='gray')
    plt.axis('off')

    # Agregar un punto rojo encima de la imagen en las coordenadas del tumor
    plt.scatter(coordenadas_tumor[0], coordenadas_tumor[1], color='red', marker='o', s=100)

    # Mostrar la imagen con el punto
    plt.show()

    return imagen

def guardar_imagen_en_drive(imagen, nombre_archivo, ruta_destino):
    """
    Guarda una imagen en una ruta específica en Google Drive.

    Args:
        imagen (numpy.ndarray): La imagen a guardar.
        nombre_archivo (str): El nombre del archivo de la imagen.
        ruta_destino (str): La ruta donde se guardará la imagen en Google Drive.
    """
    # Comprobar si la ruta de destino existe, si no, crearla
    if not os.path.exists(ruta_destino):
        os.makedirs(ruta_destino)

    # Generar la ruta completa del archivo de destino
    ruta_completa = os.path.join(ruta_destino, nombre_archivo)

    # Guardar la imagen
    plt.imshow(imagen, cmap='gray')  # Mostrar la imagen antes de guardar (opcional)
    plt.axis('off')
    plt.savefig(ruta_completa, format='png', bbox_inches='tight', pad_inches=0)  # Guardar la imagen sin bordes

    # Imprimir un mensaje de confirmación
    print(f"Imagen guardada en: {ruta_completa}")

import numpy as np
from skimage.segmentation import flood_fill

def crear_mostrar_mascara_nodulo(imagen, coordenadas_tumor, umbral=5, mostrar=True):
    """
    Crea y muestra una máscara del nódulo utilizando region growing a partir de las coordenadas dadas.

    Args:
        imagen (numpy.ndarray): La imagen de entrada.
        coordenadas_tumor (tuple): Las coordenadas del tumor en la imagen (x, y).
        umbral (int): El umbral para la expansión del region growing.
        mostrar (bool): Si se debe mostrar la imagen resultante o no.

    Returns:
        numpy.ndarray: La máscara del nódulo.
    """
    # Crear una copia de la imagen original para mantenerla intacta
    imagen_copia = imagen.copy()

    # Obtener las coordenadas iniciales de la semilla
    x, y = coordenadas_tumor

    # Realizar region growing a partir de las coordenadas de la semilla
    mascara = flood_fill(imagen_copia, (x, y), new_value=255, tolerance=umbral)

    # Convertir la máscara a valores binarios
    mascara_binaria = (mascara == 255).astype(np.uint8)

    # Mostrar la imagen resultante si se solicita
    if mostrar:
        plt.imshow(mascara_binaria, cmap='gray')
        plt.axis('off')
        plt.show()

    return mascara_binaria

def crear_mostrar_mascara_nodulo_2(imagen, coordenadas_tumor, radio=70):
    """
    Crea y muestra una máscara del nódulo en la imagen.

    Args:
        imagen (numpy.ndarray): La imagen original.
        coordenadas_tumor (tuple): Las coordenadas del tumor en la imagen en el formato (x, y).
        radio (int): El radio del nódulo en píxeles. Por defecto es 100.
    """
    # Obtener las dimensiones de la imagen
    alto, ancho = imagen.shape

    # Inicializar la máscara como un arreglo de ceros con las mismas dimensiones que la imagen
    mascara = np.zeros((alto, ancho), dtype=np.uint8)

    # Extraer las coordenadas x e y del tumor
    x, y = coordenadas_tumor

    # Crear una cuadrícula de coordenadas x y y que cubran el área del nódulo
    x_range = np.arange(max(0, x - radio), min(ancho, x + radio))
    y_range = np.arange(max(0, y - radio), min(alto, y + radio))
    xx, yy = np.meshgrid(x_range, y_range)

    # Calcular las distancias desde cada punto de la cuadrícula hasta el centro del nódulo
    distances = np.sqrt((xx - x)**2 + (yy - y)**2)

    # Marcar los puntos dentro del radio del nódulo con 255 (blanco)
    mascara[y_range[:, np.newaxis], x_range] = 255 * (distances < radio)

    # Mostrar la máscara
    plt.imshow(mascara, cmap='gray')
    plt.title('Máscara del nódulo')
    plt.axis('off')
    plt.show()

    return mascara

def procesar_imagen(numero, path, path_archivo_datos, path_mask):
    """
    Procesa una imagen según el número proporcionado.

    Args:
        numero (int): Número de la imagen.
        path (str): Ruta donde se encuentra la imagen. (¡Esto debe ser un arreglo de imagen, no una ruta!)
        path_archivo_datos (str): Ruta del archivo de datos.
        path_mask (str): Ruta donde se guardará la máscara.

    Returns:
        str: La ruta completa donde se guardó la máscara.
    """
    # Lista de números a ignorar
    numeros_a_ignorar = [9, 11, 16, 26, 28, 33, 34, 39, 40, 42, 45, 46, 63, 74, 79, 82, 89, 92, 107, 112, 135]

    # Verificar si el número está en la lista de números a ignorar
    if numero in numeros_a_ignorar:
        print(f"El número {numero} está en la lista de números a ignorar. Saltando este número.")
        return None

    # Convertir el número a una cadena con ceros a la izquierda
    numero_str = str(numero).zfill(3)

    # Reconstruir el nombre del archivo de imagen y el nombre auxiliar
    imagen_path, nombre_auxiliar = reconstruir_nombre_archivo(numero_str, path)

    imagen = cargar_mostrar_imagen(imagen_path)

    # Redimensionar la imagen
    imagen_redimensionada = redimensionar_arreglo(imagen)

    # Convertir la imagen a 8 bits
    imagen_8bits = convertir_a_8bits(imagen_redimensionada)

    # Encontrar las coordenadas del tumor
    coordenadas_tumor = encontrar_coordenadas_tumor(nombre_auxiliar, path_archivo_datos)

    # Crear y mostrar la máscara del nódulo
    mascara = crear_mostrar_mascara_nodulo(imagen_8bits, coordenadas_tumor)

    # Guardar la máscara en Google Drive
    nombre_mascara = f"mascara_{numero_str}.png"
    ruta_mascara = os.path.join(path_mask, nombre_mascara)
    guardar_imagen_en_drive(mascara, nombre_mascara, path_mask)

    return ruta_mascara

"""## Código de prueba"""

numero = 17

# Convertir el número a una cadena con ceros a la izquierda
numero_str = str(numero).zfill(3)

# Reconstruir el nombre del archivo de imagen y el nombre auxiliar
imagen_path, nombre_auxiliar = reconstruir_nombre_archivo(numero_str, path)

imagen = cargar_mostrar_imagen(imagen_path)

# Redimensionar la imagen
imagen_redimensionada = redimensionar_arreglo(imagen)

# Convertir la imagen a 8 bits
imagen_8bits = convertir_a_8bits(imagen_redimensionada)

# Encontrar las coordenadas del tumor
coordenadas_tumor = encontrar_coordenadas_tumor(nombre_auxiliar, path_archivo_datos)

coordenadas_tumor

# Aplicar ecualización de histograma con CLAHE
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
imagen_ecualizada = clahe.apply(imagen_8bits)

# Mostrar la imagen original y la ecualizada en una sola figura
plt.figure(figsize=(12, 6))

# Mostrar solo la imagen ecualizada
plt.imshow(imagen_ecualizada, cmap='gray')
plt.title('Imagen Ecualizada')
plt.axis('off')
plt.show()

x, y = coordenadas_tumor

# Dibuja un punto rojo en las coordenadas del tumor
plt.imshow(imagen_ecualizada, cmap='gray')  # Suponiendo que la imagen es en escala de grises
plt.plot(x, y, 'ro')  # 'ro' especifica que se dibuje un punto rojo
plt.title('Imagen con Punto Rojo en las Coordenadas del Tumor')
plt.axis('off')
plt.show()

# Definir el tamaño de la ventana centrada en las coordenadas del nódulo
ventana_size = (250, 250)  # Por ejemplo, una ventana de 250x250 píxeles

# Crear una máscara circular
mascara = np.zeros_like(imagen_ecualizada)
centro_x, centro_y = coordenadas_tumor
radio = ventana_size[0] // 2
cv2.circle(mascara, (centro_x, centro_y), radio, (255, 255, 255), -1)

# Aplicar la máscara a la imagen ecualizada
imagen_ecualizada_con_ventana = cv2.bitwise_and(imagen_ecualizada, mascara)

# Mostrar la imagen con la ventana centrada en las coordenadas del nódulo
plt.imshow(imagen_ecualizada_con_ventana, cmap='gray')
plt.title('Imagen Ecualizada con Ventana Circular')
plt.axis('off')
plt.show()

def escalado_int(imagen,f1,f2,fmax):
  esc=np.zeros_like(imagen)
  for i in range (len(imagen)):
    for j in range(len(imagen[0])):
      if imagen[i][j]>=f1 and imagen[i][j]<=f2:
        esc[i][j]=fmax*((imagen[i][j]-f1)/(f2-f1))
      else: esc[i][j]=0

  return esc

coordenadas_tumor

nivel_intensidad = imagen_ecualizada_con_ventana[coordenadas_tumor[1], coordenadas_tumor[0]]
nivel_intensidad

# Definir f1, f2 y fmax
f1 = nivel_intensidad - 0.5*nivel_intensidad
f2 = nivel_intensidad + 0.5*nivel_intensidad
fmax = np.max(imagen_ecualizada_con_ventana)

# Aplicar la función a la imagen
imagen_escalada = escalado_int(imagen_ecualizada_con_ventana, f1, f2, fmax)

print(f'El nivel de intensidad en las coordenadas {coordenadas_tumor} es {nivel_intensidad}')

# Mostrar la imagen procesada
plt.imshow(imagen_escalada, cmap='gray')
plt.title('Imagen Procesada')
plt.axis('off')
plt.show()

# Encuentra los contornos en la imagen procesada
contours, _ = cv2.findContours(imagen_escalada.astype(np.uint8), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Crea una máscara en blanco para dibujar los contornos
mask = np.zeros_like(imagen_escalada)

# Dibuja los contornos en la máscara
cv2.drawContours(mask, contours, -1, (255, 255, 255), thickness=cv2.FILLED)

# Aplica erosión a la máscara para "adelgazar" los contornos
kernel = np.ones((5, 5), np.uint8)
eroded_mask = cv2.erode(mask, kernel, iterations=1)

# Realiza la resta entre la imagen original y la imagen erosionada
result = cv2.absdiff(imagen_escalada, eroded_mask)

# Binariza la imagen resultante utilizando el umbral de Otsu
_, binarized_result = cv2.threshold(result, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# Aplica una operación de apertura morfológica para eliminar pequeños puntos
kernel_opening = np.ones((5, 5), np.uint8)
opened_image = cv2.morphologyEx(binarized_result, cv2.MORPH_OPEN, kernel_opening)

# Aplica una dilatación a la imagen abierta
dilated_image = cv2.dilate(opened_image, kernel, iterations=2)

# Muestra el resultado final
plt.imshow(dilated_image, cmap='gray')
plt.title('Resultado Final')
plt.axis('off')
plt.show()

def region_growing(image, seeds, int_range, p, grafico):
    # Obtener las dimensiones de la imagen
    height, width = image.shape

    # Crear una matriz para almacenar la región resultante
    region = np.zeros_like(image) #imagen negra

    # Función para verificar si un punto está dentro del rango de intensidades
    def is_in_range(pixel):
        return int_range[0] <= image[pixel[0], pixel[1]] <= int_range[1]

    # Direcciones de vecindad 8 (puedes cambiar a 4 si prefieres)
    if p == 8:
        neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]
    elif p == 4:
        neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    else:
        raise ValueError("p debe ser 4 u 8")

    # Para cada punto semilla que se ingresa
    for k in range(len(seeds)):
        coord_semilla = seeds[k]
        seed_points = [coord_semilla]
        while seed_points:
            current_seed = seed_points.pop()

            # Agregar el punto semilla a la región
            region[current_seed[0], current_seed[1]] = 255

            # Expandir la región verificando los vecinos
            for neighbor in neighbors:
                x, y = current_seed[0] + neighbor[0], current_seed[1] + neighbor[1]
                if 0 <= x < height and 0 <= y < width and region[x, y] == 0 and is_in_range((x, y)):
                    # Agregar el punto vecino a la lista de puntos semilla
                    seed_points.append((x, y))

        if grafico:
            fig, ax = plt.subplots(figsize=(5, 10))
            ax.imshow(region, cmap="gray", vmin=0, vmax=255)
            ax.set_title("Imagen Region Growing", fontsize=15)
            plt.show()

    return region

print([f1,f2])

imagen_escalada[coordenadas_tumor[1], coordenadas_tumor[0]]

region_growing(imagen_escalada,[(1614, 1090)],[8, 250],8,True)

import numpy as np

# Crear una máscara para identificar los píxeles que son 0 o mayores a 240
mascara_0_o_mayores_a_240 = (imagen_ecualizada_con_ventana == 0) | (imagen_ecualizada_con_ventana > 200)

# Asignar el valor 255 a los píxeles que cumplen la condición
imagen_procesada = np.where(mascara_0_o_mayores_a_240, 255, imagen_ecualizada_con_ventana)

# Mostrar la imagen procesada
plt.imshow(imagen_procesada, cmap='gray')
plt.title('Imagen Procesada')
plt.axis('off')
plt.show()

from skimage import exposure

# Definir el factor de aumento de contraste (gamma)
gamma = 1.5

# Aplicar la transformación de contraste
imagen_contrastada = exposure.adjust_gamma(imagen_procesada, gamma)

# Mostrar la imagen con aumento de contraste
plt.imshow(imagen_contrastada, cmap='gray')
plt.title('Imagen con Aumento de Contraste')
plt.axis('off')
plt.show()

# Aplicar TV denoising a la imagen ecualizada
tv_denoised_img = denoise_tv_chambolle(imagen_ecualizada_con_ventana, weight=2, multichannel=False)

# Mostrar la imagen denoised
plt.imshow(tv_denoised_img, cmap='gray')
plt.title('Imagen Ecualizada con TV Denoising')
plt.axis('off')
plt.show()

from sklearn.cluster import KMeans

# Reshape la imagen para que sea un array 1D
reshaped_img = tv_denoised_img.reshape((-1, 1))

# Inicializar y ajustar el modelo KMeans
kmeans = KMeans(n_clusters=6, random_state=0)
kmeans.fit(reshaped_img)

# Asignar las etiquetas de los clusters a cada píxel
cluster_labels = kmeans.predict(reshaped_img)

# Reshape las etiquetas para que tengan la misma forma que la imagen original
cluster_labels = cluster_labels.reshape(tv_denoised_img.shape)

# Mostrar la imagen segmentada
plt.imshow(cluster_labels, cmap='viridis')
plt.title('Imagen Segmentada con KMeans (5 clusters)')
plt.axis('off')
plt.show()

from skimage.filters import sobel

# Aplicar el operador de Sobel a la imagen para detectar los bordes
bordes = sobel(tv_denoised_img)

# Mostrar la imagen de los bordes
plt.imshow(bordes, cmap='gray')
plt.title('Bordes de la Imagen')
plt.axis('off')
plt.show()

# Convertir el arreglo de NumPy a una imagen de SimpleITK
imagen_sitk = sitk.GetImageFromArray(imagen_ecualizada)

# Aplicar ConnectedThreshold a la imagen de SimpleITK
Img_RG = sitk.ConnectedThreshold(imagen_sitk, seedList=[(1634,692)], lower=71, upper=104)

# Convertir el resultado a un arreglo de NumPy
Img_RG_array = sitk.GetArrayFromImage(Img_RG)

fig,ax = plt.subplots(1,2,figsize=(15,20))

# imagen_1A --> cv2.imread()
ax[0].imshow(imagen_ecualizada, vmin=0, vmax=255, cmap='gray')
ax[0].set_title('Imagen original',fontsize=15)

# imagen_1B --> sitk.ReadImage()
ax[1].imshow(Img_RG_array, vmin=0, vmax=1, cmap='gray')
ax[1].set_title('Imagen binarizada con Region growing',fontsize=15)
plt.show()

"""## Máscaras"""

for i in range(1, 155):
    procesar_imagen(i, path, path_archivo_datos, path_mask)

"""## Superposición imágenes segmentadas con máscaras"""

def superponer_imagenes(numero, path_imagenes, path_mascaras, transparencia=0.5):
    """
    Superpone una imagen original con su máscara correspondiente con cierta transparencia y muestra el resultado.

    Args:
        numero (int): Número de la imagen.
        path_imagenes (str): Ruta donde se encuentran las imágenes originales.
        path_mascaras (str): Ruta donde se encuentran las máscaras.
        transparencia (float): Nivel de transparencia de la máscara. Un valor entre 0 y 1. Por defecto es 0.5.
    """
    # Convertir el número a una cadena con ceros a la izquierda
    numero_str = str(numero).zfill(3)

    # Reconstruir el nombre del archivo de imagen y la máscara
    imagen_path = os.path.join(path_imagenes, f"imagen_{numero_str}.png")
    mascara_path = os.path.join(path_mascaras, f"mascara_{numero_str}.png")

    # Cargar la imagen original y la máscara
    imagen_original = plt.imread(imagen_path)

    # Cargar la máscara como una imagen PIL
    mascara_imagen = Image.open(mascara_path)

    # Convertir la imagen original y la máscara a formato RGBA (incluyendo el canal alfa para la transparencia)
    imagen_rgba = Image.fromarray((imagen_original * 255).astype("uint8")).convert("RGBA")
    mascara_rgba = mascara_imagen.convert("RGBA")

    # Aplicar la transparencia a la máscara
    nueva_mascara = []
    for r, g, b, a in mascara_rgba.getdata():
        nueva_mascara.append((r, g, b, int(a * transparencia)))
    mascara_rgba.putdata(nueva_mascara)

    # Superponer la máscara sobre la imagen original
    imagen_superpuesta = Image.alpha_composite(imagen_rgba, mascara_rgba)

    # Convertir la imagen superpuesta a formato numpy array
    imagen_superpuesta_np = np.array(imagen_superpuesta)

    # Mostrar la imagen superpuesta
    plt.imshow(imagen_superpuesta_np)
    plt.axis("off")
    plt.show()

# Definir la lista de números a ignorar
numeros_a_ignorar = [9, 11, 16, 26, 28, 33, 34, 39, 40, 42, 45, 46, 63, 74, 79, 82, 89, 92, 107, 112, 135]

for i in range(1, 155):
    if i in numeros_a_ignorar:
        print(f"Imagen {i}: El número {i} está en la lista de números a ignorar. Saltando este número.")
    else:
        print(f"Procesando imagen {i}...")
        superponer_imagenes(i, path, path_mask)

"""### Resultados

Por inspección visual se eliminan las siguientes imágenes:

* Máscara sobre el borde del pulmón: 12, 57, 67, 71, 73, 75, 78, 88, 93, 96, 98, 100, 101, 102, 103, 104, 117, 119, 120, 122, 125, 126, 130, 134, 137, 145, 151, 153

* Máscara fuera del pulmón: 60, 65, 105, 108, 113, 133, 136, 149, 152

37 radiografías en total descartadas por ubicación no óptima del nódulo.

21 radiografías que ya habían sido descartadas por mala segmentación de pulmones.

96 radiografías para entrenar el modelo.
"""